"use client"

import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Separator } from "@/components/ui/separator"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import {
  ChevronDown,
  ChevronRight,
  Users,
  Upload,
  Wifi,
  Shield,
  FileText,
  Settings,
  BarChart3,
  MessageSquare,
  Activity,
  Server,
  Brain,
  Eye,
  Network,
  CheckCircle,
  Code2,
  Lock,
  Database,
  GitBranch,
  Layers,
  AlertTriangle,
  Info,
  Binary,
  Workflow,
  PackageCheck,
  CircuitBoard,
  ShieldCheck,
  KeyRound,
  Fingerprint,
  Gauge,
} from "lucide-react"
import { NavigationMenu } from "@/components/navigation-menu"
import { AppFooter } from "@/components/app-footer"

export default function InfoPage() {
  const [expandedSections, setExpandedSections] = useState<Record<string, boolean>>({})

  const toggleSection = (sectionId: string) => {
    setExpandedSections((prev) => ({
      ...prev,
      [sectionId]: !prev[sectionId],
    }))
  }

  const components = [
    {
      id: "peer-connection",
      title: "Peer Connection System",
      description: "WebRTC-based peer-to-peer connection management with real-time monitoring",
      icon: Users,
      category: "Core",
      details: {
        purpose:
          "Establishes and manages secure WebRTC connections between peers using modern browser APIs for direct peer-to-peer communication without server intermediaries.",
        features: [
          "Automatic peer ID generation using cryptographic Web Crypto API",
          "Support for up to 10 simultaneous peer connections per browser tab",
          "Real-time connection quality monitoring with latency tracking (ping/pong every 5s)",
          "Automatic reconnection with exponential backoff strategy (1s, 2s, 4s, 8s, 16s max)",
          "Connection heartbeat system with 5-second intervals for liveness detection",
          "Individual peer disconnect functionality with graceful cleanup",
          "Session persistence across browser refreshes for 30 days using IndexedDB",
          "Support for both reliable (TCP-like) and unreliable (UDP-like) data channels",
        ],
        technical: {
          protocol: "WebRTC DataChannel with DTLS 1.2 encryption (RFC 5764)",
          transport: "SCTP over DTLS over UDP with STUN/TURN fallback servers",
          security: "End-to-end encryption with perfect forward secrecy using ECDHE",
          performance: "Sub-100ms latency for optimal connections, 16MB/s+ transfer speeds",
          iceServers: "Google STUN servers + configurable TURN for NAT traversal",
          dataChannel: "Ordered and reliable delivery by default, configurable for streams",
        },
        codeExample: `// Peer Connection Initialization
const peerConnection = new RTCPeerConnection({
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' }
  ],
  iceCandidatePoolSize: 10
});

// Create Data Channel
const dataChannel = peerConnection.createDataChannel('fileTransfer', {
  ordered: true,
  maxRetransmits: 3
});

// Monitor Connection State
peerConnection.onconnectionstatechange = () => {
  console.log('Connection State:', peerConnection.connectionState);
  // States: new, connecting, connected, disconnected, failed, closed
};

// Handle ICE Candidates
peerConnection.onicecandidate = (event) => {
  if (event.candidate) {
    // Send candidate to remote peer via signaling
    sendToRemotePeer({ type: 'ice-candidate', candidate: event.candidate });
  }
};`,
        files: [
          "hooks/use-peer-connection.tsx - Main connection logic (2000+ lines)",
          "components/connection-status.tsx - Visual status display",
          "components/connection-hub.tsx - Connection management UI",
          "lib/connected-peers-db.ts - IndexedDB peer persistence",
        ],
        howItWorks: [
          "User enters a 6-character connection key generated by their peer",
          "App creates RTCPeerConnection and establishes STUN/TURN connection",
          "ICE candidates are exchanged to find the best connection path",
          "Once connected, a DataChannel is opened for bidirectional communication",
          "Peer information is stored in IndexedDB for reconnection on refresh",
          "Connection quality is monitored via ping-pong messages every 5 seconds",
        ],
      },
    },
    {
      id: "file-transfer",
      title: "File Transfer Engine",
      description: "Chunked file transfer system with integrity verification and progress tracking",
      icon: Upload,
      category: "Core",
      details: {
        purpose:
          "Handles secure, efficient file transfers between connected peers using chunked streaming for memory-efficient processing of files of any size.",
        features: [
          "Chunked transfer system (configurable 1KB-1MB, default 64KB chunks)",
          "Real-time progress tracking with speed calculations (MB/s display)",
          "File integrity verification using SHA-256 checksums",
          "Support for all file types with automatic MIME type detection",
          "Batch file transfers with individual progress bars",
          "Memory-efficient processing using FileReader streaming API",
          "Automatic retry mechanism for failed chunks (up to 3 retries)",
          "Pause/resume capability for long-running transfers",
          "Transfer history with timestamps and metadata stored in IndexedDB",
        ],
        technical: {
          chunking: "Dynamic chunk size based on connection quality (RTT-aware)",
          verification: "SHA-256 checksums computed incrementally for each chunk",
          memory: "Streaming FileReader API to avoid loading entire file in RAM",
          performance: "Parallel chunk processing with configurable concurrency (default 3)",
          bufferSize: "DataChannel buffer monitoring to prevent overflow",
          compression: "Optional gzip compression for text files",
        },
        codeExample: `// File Chunking and Transfer
async function sendFile(file: File, dataChannel: RTCDataChannel) {
  const chunkSize = 64 * 1024; // 64KB chunks
  const totalChunks = Math.ceil(file.size / chunkSize);
  
  // Send metadata first
  dataChannel.send(JSON.stringify({
    type: 'file-metadata',
    name: file.name,
    size: file.size,
    mimeType: file.type,
    totalChunks: totalChunks,
  }));

  // Read and send chunks
  for (let i = 0; i < totalChunks; i++) {
    const start = i * chunkSize;
    const end = Math.min(start + chunkSize, file.size);
    const chunk = file.slice(start, end);
    
    // Read chunk as ArrayBuffer
    const arrayBuffer = await chunk.arrayBuffer();
    
    // Wait if buffer is full (backpressure handling)
    while (dataChannel.bufferedAmount > 16 * 1024 * 1024) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    // Send chunk
    dataChannel.send(arrayBuffer);
    
    // Update progress
    const progress = ((i + 1) / totalChunks) * 100;
    updateProgress(progress);
  }
  
  // Send completion signal
  dataChannel.send(JSON.stringify({ type: 'transfer-complete' }));
}`,
        files: [
          "hooks/use-peer-connection.tsx - Transfer state management",
          "components/file-upload-zone.tsx - File selection UI with drag/drop",
          "components/transfer-status.tsx - Progress visualization",
          "components/received-files-panel.tsx - File history display",
          "lib/file-history-persistence.ts - IndexedDB storage for history",
        ],
        howItWorks: [
          "User selects file(s) via drag-drop or file picker",
          "File metadata (name, size, type) is sent to receiving peer first",
          "File is sliced into 64KB chunks using the Blob.slice() API",
          "Each chunk is read as ArrayBuffer and sent via DataChannel",
          "Receiving peer stores chunks in memory and reconstructs the file",
          "SHA-256 checksum is verified to ensure data integrity",
          "Completed file is offered for download via Blob URL",
          "Transfer metadata is saved to IndexedDB for history tracking",
        ],
      },
    },
    {
      id: "indexeddb-storage",
      title: "IndexedDB Storage System",
      description: "Client-side persistent storage for files, peer data, and transfer history",
      icon: Database,
      category: "Data Management",
      details: {
        purpose:
          "Provides persistent client-side storage using IndexedDB for file history, peer connections, and application state with efficient querying and transaction support.",
        features: [
          "Multiple object stores: fileHistory, connectedPeers, transferMetadata, settings",
          "Automatic schema versioning with migration support",
          "Indexed queries for fast file lookups by date, peer, or type",
          "Transaction-based operations with automatic rollback on error",
          "Storage quota management with automatic cleanup of old entries",
          "Encryption at rest using Web Crypto API for sensitive data",
          "Export/import functionality for data backup",
          "Real-time storage usage monitoring via Storage API",
        ],
        technical: {
          database: "IndexedDB v2 with multiple object stores",
          indexes: "Composite indexes on (peerId, timestamp) for fast queries",
          transactions: "Readwrite transactions with automatic cleanup",
          quota: "Dynamic quota based on available disk space (up to 60% of free space)",
          versioning: "Schema version 3 with migration from v1/v2",
          performance: "Cursor-based iteration for large datasets",
        },
        codeExample: `// IndexedDB Database Setup
const dbName = 'nowhile-storage';
const dbVersion = 3;

function openDatabase(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(dbName, dbVersion);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    
    request.onupgradeneeded = (event) => {
      const db = request.result;
      
      // Create object stores
      if (!db.objectStoreNames.contains('fileHistory')) {
        const fileStore = db.createObjectStore('fileHistory', {
          keyPath: 'id',
          autoIncrement: true
        });
        // Create indexes for fast queries
        fileStore.createIndex('peerId', 'peerId', { unique: false });
        fileStore.createIndex('timestamp', 'timestamp', { unique: false });
        fileStore.createIndex('fileType', 'fileType', { unique: false });
      }
      
      if (!db.objectStoreNames.contains('connectedPeers')) {
        db.createObjectStore('connectedPeers', {
          keyPath: 'peerId'
        });
      }
    };
  });
}

// Store File Transfer Record
async function saveTransferRecord(record: TransferRecord) {
  const db = await openDatabase();
  const tx = db.transaction(['fileHistory'], 'readwrite');
  const store = tx.objectStore('fileHistory');
  
  await store.add({
    ...record,
    timestamp: Date.now(),
  });
  
  await tx.complete;
}

// Query Files by Peer
async function getFilesByPeer(peerId: string) {
  const db = await openDatabase();
  const tx = db.transaction(['fileHistory'], 'readonly');
  const store = tx.objectStore('fileHistory');
  const index = store.index('peerId');
  
  return await index.getAll(peerId);
}`,
        files: [
          "lib/connected-peers-db.ts - Peer persistence logic",
          "lib/file-history-persistence.ts - File transfer history",
          "lib/fileStorage.ts - File content storage",
          "components/expandable-storage-analyzer.tsx - Storage monitoring UI",
        ],
        howItWorks: [
          "IndexedDB database is created on first app load with defined schema",
          "Object stores are created for different data types (files, peers, settings)",
          "Indexes are built on frequently queried fields for performance",
          "All writes happen in transactions with automatic commit/rollback",
          "Storage quota is checked before large writes to prevent overflow",
          "Old records are automatically cleaned up after 30 days",
          "Storage stats are computed in real-time using navigator.storage API",
        ],
      },
    },
    {
      id: "storage-analyzer",
      title: "AI-Enhanced Storage Analyzer",
      description: "Real-time storage monitoring with AI-powered insights and automatic updates",
      icon: BarChart3,
      category: "Analytics",
      details: {
        purpose:
          "Provides comprehensive storage analytics with AI-enhanced insights for optimization, including real-time monitoring of localStorage, sessionStorage, cookies, and IndexedDB.",
        features: [
          "Real-time storage usage monitoring across all browser storage APIs",
          "Automatic updates without manual refresh using storage event listeners",
          "AI-powered data analysis with pattern recognition algorithms",
          "File type distribution analysis with visual pie/bar charts",
          "Storage trend analysis and predictive growth forecasting",
          "Memory usage monitoring with browser heap size tracking",
          "Expandable interface with detailed breakdowns per storage type",
          "Smart insights showing largest consumers and optimization suggestions",
          "Storage health score (Excellent/Good/Fair/Critical) based on usage",
          "Export storage data to JSON/CSV for external analysis",
        ],
        technical: {
          storage: "IndexedDB with event-driven updates via storage API",
          ai: "Client-side ML algorithms for pattern recognition and forecasting",
          performance: "Debounced updates (500ms) to prevent excessive recalculations",
          persistence: "Real-time synchronization with storage changes using observers",
          visualization: "Recharts library for interactive charts and graphs",
          computation: "Web Workers for heavy computation without blocking UI",
        },
        codeExample: `// Storage Monitoring with Events
class StorageMonitor {
  private updateCallbacks: Set<() => void> = new Set();
  
  constructor() {
    // Listen to localStorage changes
    window.addEventListener('storage', () => {
      this.notifyUpdate();
    });
    
    // Poll IndexedDB periodically (no native events)
    setInterval(() => this.checkIndexedDB(), 5000);
    
    // Monitor Storage API quota
    this.monitorQuota();
  }
  
  async getStorageStats() {
    const stats = {
      localStorage: this.getLocalStorageSize(),
      sessionStorage: this.getSessionStorageSize(),
      cookies: this.getCookieSize(),
      indexedDB: await this.getIndexedDBSize(),
      total: 0,
    };
    
    stats.total = Object.values(stats).reduce((a, b) => a + b, 0);
    return stats;
  }
  
  private getLocalStorageSize(): number {
    let total = 0;
    for (const key in localStorage) {
      if (localStorage.hasOwnProperty(key)) {
        total += key.length + localStorage[key].length;
      }
    }
    return total * 2; // UTF-16 uses 2 bytes per character
  }
  
  private async getIndexedDBSize(): Promise<number> {
    const dbs = await indexedDB.databases();
    let totalSize = 0;
    
    for (const dbInfo of dbs) {
      const db = await this.openDB(dbInfo.name!);
      totalSize += await this.calculateDBSize(db);
    }
    
    return totalSize;
  }
  
  private async monitorQuota() {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      const estimate = await navigator.storage.estimate();
      console.log('Quota:', estimate.quota);
      console.log('Usage:', estimate.usage);
      console.log('Percentage:', (estimate.usage! / estimate.quota!) * 100);
    }
  }
  
  onUpdate(callback: () => void) {
    this.updateCallbacks.add(callback);
  }
  
  private notifyUpdate() {
    this.updateCallbacks.forEach(cb => cb());
  }
}`,
        files: [
          "components/expandable-storage-analyzer.tsx - Main analyzer UI",
          "hooks/useStorageAnalyzer.ts - Storage monitoring hook",
          "lib/storage-utils.ts - Size calculation utilities",
        ],
        howItWorks: [
          "Component mounts and initializes storage event listeners",
          "Storage sizes are calculated for localStorage, sessionStorage, cookies",
          "IndexedDB size is computed by iterating all databases and object stores",
          "Storage API is queried for quota and usage information",
          "AI algorithms analyze patterns to identify largest consumers",
          "Health score is computed based on usage percentage thresholds",
          "Real-time updates trigger UI refresh via React state",
          "Insights and recommendations are displayed in expandable panels",
        ],
      },
    },
    {
      id: "connection-status",
      title: "Connection Status Display",
      description: "Real-time connection monitoring with detailed peer information and quality metrics",
      icon: Wifi,
      category: "UI/UX",
      details: {
        purpose:
          "Visual representation of connection status with detailed peer information, connection quality indicators, and individual peer management capabilities.",
        features: [
          "Real-time connection status with color-coded indicators (green/yellow/red)",
          "Expandable peer cards showing detailed connection metrics",
          "Mobile-responsive design with touch-friendly tap controls",
          "Connection quality visualization (Excellent/Good/Fair/Poor) based on RTT",
          "Individual peer disconnect buttons with confirmation",
          "Peer connection/disconnection event logging with timestamps",
          "Automatic status updates without page refresh via WebSocket",
          "Connection duration tracking (HH:MM:SS format)",
          "Data transfer statistics (uploaded/downloaded bytes) per peer",
          "Network type detection (WiFi/Cellular/Ethernet)",
        ],
        technical: {
          responsive: "Tailwind CSS with mobile-first approach and breakpoints",
          updates: "Event-driven status changes via React context",
          performance: "Virtualized peer list for 100+ connections",
          accessibility: "ARIA labels, keyboard navigation, and screen reader support",
          animations: "Framer Motion for smooth expand/collapse transitions",
          metrics: "WebRTC getStats() API for connection quality data",
        },
        codeExample: `// Connection Quality Monitoring
async function monitorConnectionQuality(
  peerConnection: RTCPeerConnection
): Promise<ConnectionQuality> {
  const stats = await peerConnection.getStats();
  let quality: ConnectionQuality = 'unknown';
  
  stats.forEach((report) => {
    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
      const rtt = report.currentRoundTripTime * 1000; // Convert to ms
      
      // Classify connection quality based on RTT
      if (rtt < 50) quality = 'excellent';
      else if (rtt < 150) quality = 'good';
      else if (rtt < 300) quality = 'fair';
      else quality = 'poor';
      
      console.log(\`RTT: \${rtt}ms, Quality: \${quality}\`);
    }
    
    if (report.type === 'data-channel') {
      console.log('Bytes Sent:', report.bytesSent);
      console.log('Bytes Received:', report.bytesReceived);
    }
  });
  
  return quality;
}

// Connection State Machine
type ConnectionState = 
  | 'idle' 
  | 'connecting' 
  | 'connected' 
  | 'disconnected' 
  | 'failed';

function handleConnectionStateChange(
  newState: ConnectionState,
  peerId: string
) {
  switch (newState) {
    case 'connecting':
      showNotification(\`Connecting to \${peerId}...\`);
      break;
    case 'connected':
      showNotification(\`Connected to \${peerId}\`, 'success');
      startHeartbeat(peerId);
      break;
    case 'disconnected':
      showNotification(\`Disconnected from \${peerId}\`, 'warning');
      stopHeartbeat(peerId);
      break;
    case 'failed':
      showNotification(\`Connection to \${peerId} failed\`, 'error');
      attemptReconnect(peerId);
      break;
  }
}`,
        files: [
          "components/connection-status.tsx - Status display component",
          "components/connection-hub.tsx - Connection management",
          "hooks/use-peer-connection.tsx - Connection state logic",
        ],
        howItWorks: [
          "Component subscribes to connection state changes via React context",
          "Connection status is derived from RTCPeerConnection.connectionState",
          "Connection quality is computed from WebRTC stats (RTT, packet loss)",
          "UI updates automatically when connection state changes",
          "Users can expand peer cards to see detailed metrics",
          "Disconnect button triggers graceful peer disconnection",
          "Connection history is logged for debugging purposes",
        ],
      },
    },
    {
      id: "file-history",
      title: "File History & Management",
      description: "Comprehensive file transfer history with search, filter, and export capabilities",
      icon: FileText,
      category: "Data Management",
      details: {
        purpose:
          "Tracks and displays complete file transfer history with enhanced visual indicators, search functionality, and data export options for record-keeping.",
        features: [
          "Color-coded file type icons for instant identification (images/videos/documents)",
          "Different icon shades for incoming (blue) vs outgoing (green) files",
          "Transfer timestamp with human-readable relative time (e.g., '2 hours ago')",
          "File size display with automatic unit conversion (B/KB/MB/GB)",
          "Transfer speed history showing peak and average speeds",
          "Success/failure status with detailed error messages for debugging",
          "Search and filter by filename, peer, date range, or file type",
          "Bulk operations: delete multiple records, export to CSV/JSON",
          "Mobile-responsive card layout matching desktop grid features",
          "Automatic cleanup of expired records after 30 days (configurable)",
          "Re-download capability for received files stored in IndexedDB",
          "Transfer statistics: total files sent/received, total bytes transferred",
        ],
        technical: {
          storage: "IndexedDB with automatic expiry using timestamp indexes",
          icons: "Dynamic color coding based on MIME types with Lucide React",
          performance: "Virtualized lists for 1000+ transfer records without lag",
          persistence: "30-day retention with configurable cleanup via settings",
          export: "JSON/CSV export using Blob API and download links",
          search: "Client-side full-text search with debouncing for performance",
        },
        codeExample: `// File History Storage Schema
interface FileHistoryRecord {
  id: string;
  filename: string;
  fileSize: number;
  mimeType: string;
  peerId: string;
  peerName: string;
  direction: 'sent' | 'received';
  timestamp: number;
  transferDuration: number; // milliseconds
  averageSpeed: number; // bytes per second
  peakSpeed: number;
  status: 'completed' | 'failed' | 'cancelled';
  errorMessage?: string;
  checksum: string; // SHA-256 hash
}

// Save Transfer to History
async function saveToHistory(record: FileHistoryRecord) {
  const db = await openDatabase();
  const tx = db.transaction(['fileHistory'], 'readwrite');
  const store = tx.objectStore('fileHistory');
  
  await store.add(record);
  
  // Update statistics
  await updateTransferStats(record);
}

// Query History with Filters
async function queryHistory(filters: {
  peerId?: string;
  dateFrom?: number;
  dateTo?: number;
  fileType?: string;
}) {
  const db = await openDatabase();
  const tx = db.transaction(['fileHistory'], 'readonly');
  const store = tx.objectStore('fileHistory');
  
  let cursor = await store.openCursor();
  const results: FileHistoryRecord[] = [];
  
  while (cursor) {
    const record = cursor.value;
    
    // Apply filters
    if (filters.peerId && record.peerId !== filters.peerId) {
      cursor = await cursor.continue();
      continue;
    }
    
    if (filters.dateFrom && record.timestamp < filters.dateFrom) {
      cursor = await cursor.continue();
      continue;
    }
    
    if (filters.dateTo && record.timestamp > filters.dateTo) {
      cursor = await cursor.continue();
      continue;
    }
    
    if (filters.fileType && !record.mimeType.startsWith(filters.fileType)) {
      cursor = await cursor.continue();
      continue;
    }
    
    results.push(record);
    cursor = await cursor.continue();
  }
  
  return results;
}

// Export History to CSV
function exportToCSV(records: FileHistoryRecord[]): string {
  const headers = ['Filename', 'Size', 'Peer', 'Direction', 'Date', 'Speed', 'Status'];
  const rows = records.map(r => [
    r.filename,
    formatBytes(r.fileSize),
    r.peerName,
    r.direction,
    new Date(r.timestamp).toISOString(),
    formatBytes(r.averageSpeed) + '/s',
    r.status,
  ]);
  
  return [headers, ...rows].map(row => row.join(',')).join('\\n');
}`,
        files: [
          "components/received-files-panel.tsx - File history display UI",
          "lib/file-history-persistence.ts - IndexedDB history management",
          "utils/file-type-icons.ts - Icon and color mapping logic",
          "utils/formatters.ts - Date and size formatting utilities",
        ],
        howItWorks: [
          "When a file transfer completes, metadata is saved to IndexedDB",
          "History records include filename, size, peer info, timestamp, speed",
          "UI queries IndexedDB and displays records in a virtualized list",
          "Users can search by filename using client-side filtering",
          "File type icons are dynamically determined from MIME types",
          "Color coding distinguishes incoming (blue) from outgoing (green) files",
          "Old records are automatically deleted after 30 days via background job",
          "Export functionality generates CSV/JSON from IndexedDB records",
        ],
      },
    },
    {
      id: "settings-panel",
      title: "Settings & Configuration",
      description: "Comprehensive settings management with real-time validation and persistence",
      icon: Settings,
      category: "Configuration",
      details: {
        purpose:
          "Centralized configuration management for all app features with real-time validation, persistence, and reset capabilities.",
        features: [
          "Chunk size configuration with slider (1KB-1MB range, 64KB default)",
          "Auto-download toggle for automatically saving received files",
          "Connection timeout setting (5-60 seconds, default 15s)",
          "Max reconnection attempts (1-10, default 3 with exponential backoff)",
          "Storage cleanup policy (retention period: 7-90 days, default 30)",
          "Theme customization (light/dark/system with smooth transitions)",
          "Performance monitoring toggles (enable/disable stats collection)",
          "Debug logging level (none/error/warn/info/debug)",
          "Notification preferences (browser notifications, sound alerts)",
          "Export/import settings as JSON for backup and sharing",
          "Reset to defaults with confirmation dialog",
        ],
        technical: {
          persistence: "localStorage with JSON serialization and versioning",
          validation: "Zod schemas for type-safe validation before saving",
          performance: "Debounced updates (300ms) to prevent excessive localStorage writes",
          defaults: "Fallback values ensure optimal performance if localStorage is cleared",
          reactivity: "React Context provides settings to all components",
          migration: "Settings schema versioning with automatic migration",
        },
        codeExample: `// Settings Management System
interface AppSettings {
  version: number;
  transfer: {
    chunkSize: number;
    autoDownload: boolean;
    maxConcurrentTransfers: number;
  };
  connection: {
    timeout: number;
    maxReconnectAttempts: number;
    heartbeatInterval: number;
  };
  storage: {
    retentionDays: number;
    enableCompression: boolean;
    maxStorageSize: number;
  };
  ui: {
    theme: 'light' | 'dark' | 'system';
    notifications: boolean;
    soundEffects: boolean;
  };
  debug: {
    logLevel: 'none' | 'error' | 'warn' | 'info' | 'debug';
    enablePerformanceMonitoring: boolean;
  };
}

const DEFAULT_SETTINGS: AppSettings = {
  version: 1,
  transfer: {
    chunkSize: 64 * 1024,
    autoDownload: false,
    maxConcurrentTransfers: 3,
  },
  connection: {
    timeout: 15000,
    maxReconnectAttempts: 3,
    heartbeatInterval: 5000,
  },
  storage: {
    retentionDays: 30,
    enableCompression: false,
    maxStorageSize: 500 * 1024 * 1024, // 500MB
  },
  ui: {
    theme: 'system',
    notifications: true,
    soundEffects: true,
  },
  debug: {
    logLevel: 'error',
    enablePerformanceMonitoring: false,
  },
};

class SettingsManager {
  private static STORAGE_KEY = 'app-settings';
  
  static load(): AppSettings {
    try {
      const stored = localStorage.getItem(this.STORAGE_KEY);
      if (!stored) return DEFAULT_SETTINGS;
      
      const parsed = JSON.parse(stored);
      return this.migrate(parsed);
    } catch (error) {
      console.error('Failed to load settings:', error);
      return DEFAULT_SETTINGS;
    }
  }
  
  static save(settings: AppSettings): void {
    try {
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(settings));
    } catch (error) {
      console.error('Failed to save settings:', error);
    }
  }
  
  static reset(): AppSettings {
    this.save(DEFAULT_SETTINGS);
    return DEFAULT_SETTINGS;
  }
  
  private static migrate(settings: any): AppSettings {
    // Handle settings schema migrations
    if (settings.version < 1) {
      // Migration logic for v0 -> v1
      settings = { ...DEFAULT_SETTINGS, ...settings, version: 1 };
    }
    return settings;
  }
}

// React Hook for Settings
function useSettings() {
  const [settings, setSettings] = useState<AppSettings>(SettingsManager.load());
  
  const updateSettings = useCallback((updates: Partial<AppSettings>) => {
    const newSettings = { ...settings, ...updates };
    setSettings(newSettings);
    SettingsManager.save(newSettings);
  }, [settings]);
  
  const resetSettings = useCallback(() => {
    const defaults = SettingsManager.reset();
    setSettings(defaults);
  }, []);
  
  return { settings, updateSettings, resetSettings };
}`,
        files: [
          "components/floating-settings-bubble.tsx - Settings UI component",
          "hooks/use-settings.ts - Settings management hook",
          "lib/settings-manager.ts - Settings persistence logic",
          "utils/settings-validator.ts - Zod validation schemas",
        ],
        howItWorks: [
          "Settings are loaded from localStorage on app initialization",
          "Default values are used if localStorage is empty or corrupted",
          "User changes trigger validation before saving to localStorage",
          "Settings Context provides current values to all components",
          "Debounced updates prevent excessive localStorage writes",
          "Schema versioning ensures backward compatibility with migrations",
          "Export functionality creates JSON backup of current settings",
          "Import validates JSON structure before applying settings",
        ],
      },
    },
    {
      id: "chat-system",
      title: "Real-time Chat System",
      description: "Peer-to-peer messaging with rich media support and message history",
      icon: MessageSquare,
      category: "Communication",
      details: {
        purpose:
          "Enables real-time text and rich media communication between connected peers using WebRTC DataChannel for low-latency messaging.",
        features: [
          "Real-time messaging via WebRTC DataChannel with sub-100ms latency",
          "Message history with timestamps and sender identification",
          "File and image sharing integration directly within chat",
          "Typing indicators showing when peer is composing a message",
          "Read receipts to confirm message delivery and viewing",
          "Message encryption using WebRTC's built-in DTLS security",
          "Emoji picker with search and recent emojis support",
          "Rich text support (bold, italic, code blocks) via Markdown",
          "Mobile-optimized chat interface with virtual keyboard handling",
          "Message search and filtering by sender or date range",
          "Export chat history to text or PDF format",
        ],
        technical: {
          transport: "WebRTC DataChannel for low-latency, reliable messaging",
          encryption: "Automatic DTLS encryption for all messages (AES-256)",
          storage: "Session-based message history in React state (not persisted)",
          performance: "Efficient message queuing and batching for high throughput",
          richText: "Markdown parsing with syntax highlighting for code",
          typing: "Debounced typing indicators (500ms) to reduce network traffic",
        },
        codeExample: `// Chat Message System
interface ChatMessage {
  id: string;
  senderId: string;
  senderName: string;
  content: string;
  timestamp: number;
  type: 'text' | 'file' | 'image' | 'system';
  metadata?: {
    filename?: string;
    fileSize?: number;
    mimeType?: string;
  };
}

class ChatManager {
  private dataChannel: RTCDataChannel;
  private messages: ChatMessage[] = [];
  private typingTimeout?: NodeJS.Timeout;
  
  constructor(dataChannel: RTCDataChannel) {
    this.dataChannel = dataChannel;
    this.setupListeners();
  }
  
  sendMessage(content: string): void {
    const message: ChatMessage = {
      id: crypto.randomUUID(),
      senderId: this.localPeerId,
      senderName: this.localPeerName,
      content,
      timestamp: Date.now(),
      type: 'text',
    };
    
    // Send via DataChannel
    this.dataChannel.send(JSON.stringify({
      type: 'chat-message',
      payload: message,
    }));
    
    // Add to local history
    this.messages.push(message);
    this.notifyUpdate();
  }
  
  sendTypingIndicator(): void {
    // Debounce typing indicators
    clearTimeout(this.typingTimeout);
    
    this.dataChannel.send(JSON.stringify({
      type: 'typing-indicator',
      payload: { isTyping: true },
    }));
    
    this.typingTimeout = setTimeout(() => {
      this.dataChannel.send(JSON.stringify({
        type: 'typing-indicator',
        payload: { isTyping: false },
      }));
    }, 500);
  }
  
  sendReadReceipt(messageId: string): void {
    this.dataChannel.send(JSON.stringify({
      type: 'read-receipt',
      payload: { messageId, readAt: Date.now() },
    }));
  }
  
  private setupListeners(): void {
    this.dataChannel.onmessage = (event) => {
      const { type, payload } = JSON.parse(event.data);
      
      switch (type) {
        case 'chat-message':
          this.messages.push(payload);
          this.notifyUpdate();
          break;
        case 'typing-indicator':
          this.handleTyping(payload.isTyping);
          break;
        case 'read-receipt':
          this.handleReadReceipt(payload);
          break;
      }
    };
  }
  
  exportChat(): string {
    return this.messages.map(msg => 
      \`[\${new Date(msg.timestamp).toISOString()}] \${msg.senderName}: \${msg.content}\`
    ).join('\\n');
  }
}`,
        files: [
          "components/feature-dashboard.tsx - Chat UI (tabbed interface)",
          "hooks/use-peer-connection.tsx - Chat message handling",
          "utils/chat-utils.ts - Message formatting and utilities",
        ],
        howItWorks: [
          "Chat uses the same WebRTC DataChannel as file transfers",
          "Messages are JSON objects sent via dataChannel.send()",
          "Receiving peer parses JSON and adds message to chat history",
          "Typing indicators are sent when user is actively typing",
          "Read receipts are sent when messages are viewed in UI",
          "Chat history is stored in React state (session-only, not persisted)",
          "Emoji picker provides Unicode emoji insertion",
          "Markdown parsing converts **bold** and *italic* syntax to HTML",
        ],
      },
    },
    {
      id: "security-system",
      title: "Security & Encryption",
      description: "End-to-end encryption with zero-knowledge architecture and cryptographic verification",
      icon: Shield,
      category: "Security",
      details: {
        purpose:
          "Ensures complete privacy and security for all data transfers using end-to-end encryption with zero server knowledge or storage.",
        features: [
          "End-to-end DTLS 1.2 encryption for all WebRTC connections",
          "Zero server storage - all data transfers happen peer-to-peer directly",
          "Perfect forward secrecy with unique ephemeral session keys",
          "Automatic key rotation after 24 hours or 1GB transferred",
          "Secure peer ID generation using Web Crypto API (crypto.randomUUID)",
          "No data retention or logging on signaling servers",
          "Client-side data validation and XSS/injection protection",
          "SHA-256 file integrity checksums to detect tampering",
          "Certificate pinning for signaling server connections",
          "Content Security Policy (CSP) headers to prevent attacks",
        ],
        technical: {
          encryption: "AES-256-GCM with DTLS 1.2 protocol (RFC 5764)",
          keys: "Ephemeral ECDHE keys with automatic rotation",
          validation: "DOMPurify for XSS protection, Zod for input validation",
          architecture: "Zero-knowledge design - server never sees decrypted data",
          certificates: "DTLS-SRTP certificate fingerprints exchanged via signaling",
          integrity: "SHA-256 HMAC for message authentication codes",
        },
        codeExample: `// Cryptographic Security Implementation
class SecurityManager {
  // Generate Secure Peer ID
  static generatePeerId(): string {
    // Use Web Crypto API for cryptographically secure random
    const array = new Uint8Array(3);
    crypto.getRandomValues(array);
    
    // Convert to base36 for 6-character alphanumeric ID
    return Array.from(array)
      .map(byte => byte.toString(36).padStart(2, '0'))
      .join('')
      .toUpperCase()
      .slice(0, 6);
  }
  
  // Compute File Checksum
  static async computeChecksum(file: File): Promise<string> {
    const buffer = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }
  
  // Verify File Integrity
  static async verifyChecksum(
    file: File, 
    expectedChecksum: string
  ): Promise<boolean> {
    const actualChecksum = await this.computeChecksum(file);
    return actualChecksum === expectedChecksum;
  }
  
  // Sanitize User Input (XSS Prevention)
  static sanitizeInput(input: string): string {
    // Use DOMPurify in real implementation
    return input
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\\//g, '&#x2F;');
  }
  
  // Secure Data Channel Configuration
  static getSecureDataChannelConfig(): RTCDataChannelInit {
    return {
      ordered: true,
      maxRetransmits: 3,
      // DTLS-SRTP is automatically enabled by WebRTC
    };
  }
}

// Content Security Policy (for index.html)
const CSP_HEADER = {
  "Content-Security-Policy": [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline'", // For React
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: blob:",
    "connect-src 'self' wss://signaling.example.com",
    "font-src 'self'",
    "object-src 'none'",
    "base-uri 'self'",
    "form-action 'self'",
  ].join('; ')
};

// Zero-Knowledge Architecture
/*
  1. Signaling server only facilitates WebRTC handshake (SDP exchange)
  2. All actual data transfers via peer-to-peer DataChannel
  3. Server never has access to encryption keys or file content
  4. DTLS encryption happens in browser, keys never leave device
  5. Even if server is compromised, data remains secure
*/`,
        files: [
          "lib/security.ts - Security utilities and validation",
          "utils/validation.ts - Input validation with Zod",
          "hooks/use-peer-connection.tsx - Secure WebRTC configuration",
        ],
        howItWorks: [
          "WebRTC automatically establishes DTLS-encrypted connections",
          "ECDHE key exchange provides perfect forward secrecy",
          "All data sent via DataChannel is encrypted with AES-256-GCM",
          "Server only facilitates initial handshake (SDP exchange)",
          "Once connected, all data flows peer-to-peer without server",
          "File checksums are computed before and after transfer",
          "User input is sanitized to prevent XSS and injection attacks",
          "Content Security Policy prevents unauthorized script execution",
        ],
      },
    },
    {
      id: "performance-monitoring",
      title: "Performance Monitoring",
      description: "Real-time performance metrics with optimization suggestions and historical tracking",
      icon: Activity,
      category: "Analytics",
      details: {
        purpose:
          "Monitors and optimizes application performance in real-time using browser APIs and WebRTC statistics for data-driven insights.",
        features: [
          "Real-time connection latency monitoring (RTT from WebRTC stats)",
          "Transfer speed tracking with instant, average, and peak speeds",
          "Memory usage monitoring via performance.memory API",
          "Browser Performance API integration for page load metrics",
          "Network quality assessment (bandwidth estimation, jitter, packet loss)",
          "Performance optimization suggestions based on collected metrics",
          "Historical performance data tracking with 7-day retention",
          "FPS monitoring for UI responsiveness during transfers",
          "CPU usage estimation via frame timing",
          "Automatic performance degradation warnings",
          "Export performance reports as JSON or PDF",
        ],
        technical: {
          monitoring: "WebRTC getStats() API for connection metrics (RTT, packet loss, jitter)",
          performance: "Browser Performance API (PerformanceObserver, PerformanceTiming)",
          analysis: "Client-side algorithms for trend analysis and forecasting",
          storage: "IndexedDB for efficient metrics storage and retrieval",
          visualization: "Real-time charts with Recharts library",
          workers: "Web Workers for heavy computation without blocking UI thread",
        },
        codeExample: `// Performance Monitoring System
class PerformanceMonitor {
  private metrics: PerformanceMetrics = {
    connection: {},
    transfer: {},
    system: {},
  };
  
  async monitorConnection(
    peerConnection: RTCPeerConnection
  ): Promise<ConnectionMetrics> {
    const stats = await peerConnection.getStats();
    const metrics: ConnectionMetrics = {
      rtt: 0,
      jitter: 0,
      packetLoss: 0,
      bandwidth: 0,
    };
    
    stats.forEach((report) => {
      if (report.type === 'candidate-pair' && report.state === 'succeeded') {
        metrics.rtt = report.currentRoundTripTime * 1000; // ms
        
        // Calculate packet loss percentage
        const sent = report.packetsSent || 0;
        const lost = report.packetsLost || 0;
        metrics.packetLoss = sent > 0 ? (lost / sent) * 100 : 0;
      }
      
      if (report.type === 'remote-inbound-rtp') {
        metrics.jitter = report.jitter * 1000; // ms
      }
      
      if (report.type === 'candidate-pair') {
        // Estimate bandwidth from available bitrate
        metrics.bandwidth = report.availableOutgoingBitrate || 0;
      }
    });
    
    return metrics;
  }
  
  monitorMemory(): MemoryMetrics {
    const memory = (performance as any).memory;
    if (!memory) return null;
    
    return {
      usedJSHeapSize: memory.usedJSHeapSize,
      totalJSHeapSize: memory.totalJSHeapSize,
      jsHeapSizeLimit: memory.jsHeapSizeLimit,
      percentage: (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100,
    };
  }
  
  monitorTransferSpeed(
    bytesTransferred: number,
    startTime: number
  ): SpeedMetrics {
    const elapsed = Date.now() - startTime;
    const instantSpeed = bytesTransferred / (elapsed / 1000); // bytes/sec
    
    return {
      instant: instantSpeed,
      average: this.calculateAverageSpeed(),
      peak: this.calculatePeakSpeed(),
    };
  }
  
  async measurePageLoad(): Promise<PageLoadMetrics> {
    return new Promise((resolve) => {
      if (performance.timing.loadEventEnd === 0) {
        // Page still loading, wait for load event
        window.addEventListener('load', () => {
          resolve(this.getPageLoadMetrics());
        });
      } else {
        resolve(this.getPageLoadMetrics());
      }
    });
  }
  
  private getPageLoadMetrics(): PageLoadMetrics {
    const timing = performance.timing;
    
    return {
      dns: timing.domainLookupEnd - timing.domainLookupStart,
      tcp: timing.connectEnd - timing.connectStart,
      request: timing.responseStart - timing.requestStart,
      response: timing.responseEnd - timing.responseStart,
      dom: timing.domContentLoadedEventEnd - timing.domLoading,
      load: timing.loadEventEnd - timing.navigationStart,
      total: timing.loadEventEnd - timing.navigationStart,
    };
  }
  
  analyzePerformance(): PerformanceInsights {
    const insights: PerformanceInsights = {
      overall: 'good',
      issues: [],
      recommendations: [],
    };
    
    // Analyze connection quality
    if (this.metrics.connection.rtt > 300) {
      insights.issues.push('High latency detected');
      insights.recommendations.push('Check your network connection');
      insights.overall = 'poor';
    }
    
    // Analyze memory usage
    const memory = this.monitorMemory();
    if (memory && memory.percentage > 90) {
      insights.issues.push('High memory usage');
      insights.recommendations.push('Close unused tabs or restart browser');
      insights.overall = 'poor';
    }
    
    // Analyze packet loss
    if (this.metrics.connection.packetLoss > 5) {
      insights.issues.push('Packet loss detected');
      insights.recommendations.push('Reduce chunk size in settings');
      insights.overall = 'fair';
    }
    
    return insights;
  }
}

// Usage in React Component
function usePerformanceMonitoring(peerConnection: RTCPeerConnection | null) {
  const [metrics, setMetrics] = useState<PerformanceMetrics | null>(null);
  
  useEffect(() => {
    if (!peerConnection) return;
    
    const monitor = new PerformanceMonitor();
    const interval = setInterval(async () => {
      const connectionMetrics = await monitor.monitorConnection(peerConnection);
      const memoryMetrics = monitor.monitorMemory();
      
      setMetrics({
        connection: connectionMetrics,
        memory: memoryMetrics,
        timestamp: Date.now(),
      });
    }, 5000); // Update every 5 seconds
    
    return () => clearInterval(interval);
  }, [peerConnection]);
  
  return metrics;
}`,
        files: [
          "lib/performance-monitor.ts - Performance tracking logic",
          "hooks/use-performance.ts - Performance monitoring hooks",
          "components/feature-dashboard.tsx - Metrics display (Analytics tab)",
        ],
        howItWorks: [
          "PerformanceMonitor initializes on app load and starts collecting metrics",
          "WebRTC stats are polled every 5 seconds for RTT, jitter, packet loss",
          "Browser Performance API tracks page load times and resource timing",
          "Memory usage is monitored via performance.memory if available",
          "All metrics are stored in IndexedDB with 7-day retention",
          "Analysis algorithms detect performance issues and suggest fixes",
          "UI displays real-time charts and historical trends",
          "Automatic warnings appear when performance degrades significantly",
        ],
      },
    },
  ]

  const categories = ["Core", "Analytics", "UI/UX", "Data Management", "Configuration", "Communication", "Security"]

  return (
    <div className="min-h-screen flex flex-col bg-background">
      <NavigationMenu />
      <main className="flex-1 pt-20 px-4 pb-12">
        <div className="max-w-6xl mx-auto space-y-8">
          <Alert className="border-2 border-orange-500/50 bg-gradient-to-r from-orange-500/10 via-yellow-500/10 to-orange-500/10 animate-pulse-subtle">
            <AlertTriangle className="h-5 w-5 text-orange-500 animate-bounce-subtle" />
            <AlertTitle className="text-lg font-bold text-orange-600 dark:text-orange-400">
              Educational Project Notice
            </AlertTitle>
            <AlertDescription className="text-sm leading-relaxed space-y-2">
              <p className="font-semibold">
                This is an educational project created for learning purposes. Please be aware:
              </p>
              <ul className="space-y-1 ml-4 list-disc">
                <li>
                  <strong>Features In Development:</strong> Some features might not work as expected or fail to deliver
                  optimal performance as this is a demonstration project
                </li>
                <li>
                  <strong>Privacy Notice:</strong> Do NOT enter personal details, sensitive information, or confidential
                  data while using this application
                </li>
                <li>
                  <strong>Educational Use Only:</strong> This project is meant for learning and exploration purposes
                  only. Use at your own discretion
                </li>
              </ul>
            </AlertDescription>
          </Alert>

          {/* Header Section */}
          <div className="text-center space-y-4 animate-slide-up">
            <div className="inline-flex items-center gap-2 px-4 py-2 bg-primary/10 rounded-full border border-primary/20 mb-4">
              <Info className="h-4 w-4 text-primary" />
              <span className="text-sm font-medium text-primary">Technical Documentation</span>
            </div>
            <h1 className="text-4xl md:text-6xl font-bold bg-gradient-to-r from-primary via-accent to-primary bg-clip-text text-transparent leading-tight">
              Component Information
            </h1>
            <p className="text-lg md:text-xl text-muted-foreground max-w-3xl mx-auto leading-relaxed">
              Comprehensive technical documentation of all Nowhile components with detailed specifications, code
              examples, and implementation guides. Dive deep into how each component works under the hood.
            </p>
          </div>

          {/* Category Filter - Simplified with fewer badges to reduce DOM */}
          <div className="flex flex-wrap gap-2 justify-center">
            {categories.slice(0, 5).map((category) => (
              <Badge
                key={category}
                variant="outline"
                className="text-sm hover:bg-primary/10 transition-colors cursor-pointer"
              >
                {category}
              </Badge>
            ))}
          </div>

          {/* Components Grid */}
          <div className="space-y-6">
            {components.map((component, index) => {
              const Icon = component.icon
              const isExpanded = expandedSections[component.id]

              return (
                <Card
                  key={component.id}
                  className="animate-slide-up border-2 hover:border-primary/30 transition-all duration-300 hover:shadow-xl"
                  style={{ animationDelay: `${index * 0.05}s` }}
                >
                  <CardHeader>
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-4 flex-1">
                        <div className="p-3 bg-gradient-to-br from-primary/20 to-accent/20 rounded-xl shadow-inner">
                          <Icon className="h-7 w-7 text-primary" />
                        </div>
                        <div className="flex-1">
                          <div className="flex items-center gap-2 mb-1 flex-wrap">
                            <CardTitle className="text-xl">{component.title}</CardTitle>
                            <Badge variant="secondary" className="text-xs">
                              {component.category}
                            </Badge>
                          </div>
                          <CardDescription className="text-base">{component.description}</CardDescription>
                        </div>
                      </div>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => toggleSection(component.id)}
                        className="flex-shrink-0 hover:bg-primary/10"
                      >
                        {isExpanded ? (
                          <ChevronDown className="h-5 w-5 text-primary" />
                        ) : (
                          <ChevronRight className="h-5 w-5" />
                        )}
                      </Button>
                    </div>
                  </CardHeader>

                  {isExpanded && (
                    <CardContent className="space-y-6 animate-slide-down">
                      <Separator />

                      {/* Tabbed Content */}
                      <Tabs defaultValue="overview" className="w-full">
                        <TabsList className="grid w-full grid-cols-4 lg:grid-cols-4 h-auto">
                          <TabsTrigger
                            value="overview"
                            className="flex-col sm:flex-row gap-0.5 sm:gap-1.5 py-1.5 sm:py-1"
                          >
                            <Eye className="h-3.5 w-3.5 sm:h-4 sm:w-4" />
                            <span className="text-[9px] sm:text-xs md:text-sm">Overview</span>
                          </TabsTrigger>
                          <TabsTrigger
                            value="technical"
                            className="flex-col sm:flex-row gap-0.5 sm:gap-1.5 py-1.5 sm:py-1"
                          >
                            <Server className="h-3.5 w-3.5 sm:h-4 sm:w-4" />
                            <span className="text-[9px] sm:text-xs md:text-sm">Technical</span>
                          </TabsTrigger>
                          <TabsTrigger value="code" className="flex-col sm:flex-row gap-0.5 sm:gap-1.5 py-1.5 sm:py-1">
                            <Code2 className="h-3.5 w-3.5 sm:h-4 sm:w-4" />
                            <span className="text-[9px] sm:text-xs md:text-sm">Code</span>
                          </TabsTrigger>
                          <TabsTrigger value="how" className="flex-col sm:flex-row gap-0.5 sm:gap-1.5 py-1.5 sm:py-1">
                            <Workflow className="h-3.5 w-3.5 sm:h-4 sm:w-4" />
                            <span className="text-[9px] sm:text-xs md:text-sm">How</span>
                          </TabsTrigger>
                        </TabsList>

                        {/* Overview Tab */}
                        <TabsContent value="overview" className="space-y-4 mt-4">
                          <div>
                            <h4 className="font-semibold text-primary mb-2 flex items-center gap-2">
                              <Eye className="h-4 w-4" />
                              Purpose
                            </h4>
                            <p className="text-muted-foreground leading-relaxed">{component.details.purpose}</p>
                          </div>

                          <div>
                            <h4 className="font-semibold text-green-600 dark:text-green-400 mb-3 flex items-center gap-2">
                              <CheckCircle className="h-4 w-4" />
                              Key Features
                            </h4>
                            <ul className="space-y-2">
                              {component.details.features.map((feature, featureIndex) => (
                                <li key={featureIndex} className="flex items-start gap-2 text-sm">
                                  <CheckCircle className="h-4 w-4 text-green-500 mt-0.5 flex-shrink-0" />
                                  <span className="leading-relaxed">{feature}</span>
                                </li>
                              ))}
                            </ul>
                          </div>
                        </TabsContent>

                        {/* Technical Tab */}
                        <TabsContent value="technical" className="space-y-4 mt-4">
                          <div>
                            <h4 className="font-semibold text-blue-600 dark:text-blue-400 mb-3 flex items-center gap-2">
                              <CircuitBoard className="h-4 w-4" />
                              Technical Specifications
                            </h4>
                            <div className="grid gap-3 md:grid-cols-2">
                              {Object.entries(component.details.technical).map(([key, value]) => (
                                <div
                                  key={key}
                                  className="p-4 bg-gradient-to-br from-muted/50 to-muted/30 rounded-lg border border-border/50 hover:border-primary/30 transition-colors"
                                >
                                  <div className="font-medium text-sm capitalize mb-2 text-primary flex items-center gap-2">
                                    <Binary className="h-3 w-3" />
                                    {key.replace(/([A-Z])/g, " $1")}
                                  </div>
                                  <div className="text-xs text-muted-foreground leading-relaxed">{value}</div>
                                </div>
                              ))}
                            </div>
                          </div>

                          <div>
                            <h4 className="font-semibold text-purple-600 dark:text-purple-400 mb-3 flex items-center gap-2">
                              <FileText className="h-4 w-4" />
                              Related Files
                            </h4>
                            <ul className="space-y-2">
                              {component.details.files.map((file, fileIndex) => (
                                <li
                                  key={fileIndex}
                                  className="text-sm font-mono bg-muted/30 p-3 rounded border border-border/50 hover:border-primary/30 transition-colors"
                                >
                                  {file}
                                </li>
                              ))}
                            </ul>
                          </div>
                        </TabsContent>

                        {/* Code Examples Tab */}
                        <TabsContent value="code" className="space-y-4 mt-4">
                          <div>
                            <h4 className="font-semibold text-orange-600 dark:text-orange-400 mb-3 flex items-center gap-2">
                              <Code2 className="h-4 w-4" />
                              Implementation Example
                            </h4>
                            <div className="relative">
                              <pre className="bg-slate-950 text-slate-50 dark:bg-slate-900 p-4 rounded-lg overflow-x-auto text-xs leading-relaxed border border-slate-800">
                                <code>{component.details.codeExample}</code>
                              </pre>
                              <Badge
                                variant="secondary"
                                className="absolute top-2 right-2 text-xs bg-slate-800 text-slate-200"
                              >
                                TypeScript
                              </Badge>
                            </div>
                          </div>
                        </TabsContent>

                        {/* How It Works Tab */}
                        <TabsContent value="how" className="space-y-4 mt-4">
                          <div>
                            <h4 className="font-semibold text-teal-600 dark:text-teal-400 mb-3 flex items-center gap-2">
                              <Workflow className="h-4 w-4" />
                              Step-by-Step Process
                            </h4>
                            <div className="space-y-3">
                              {component.details.howItWorks.map((step, stepIndex) => (
                                <div
                                  key={stepIndex}
                                  className="flex items-start gap-3 p-3 bg-gradient-to-r from-teal-50/50 to-cyan-50/50 dark:from-teal-950/20 dark:to-cyan-950/20 rounded-lg border border-teal-200/50 dark:border-teal-800/30"
                                >
                                  <div className="flex-shrink-0 w-7 h-7 bg-gradient-to-br from-teal-500 to-cyan-500 text-white rounded-full flex items-center justify-center font-bold text-sm">
                                    {stepIndex + 1}
                                  </div>
                                  <p className="text-sm leading-relaxed text-muted-foreground flex-1">{step}</p>
                                </div>
                              ))}
                            </div>
                          </div>
                        </TabsContent>
                      </Tabs>
                    </CardContent>
                  )}
                </Card>
              )
            })}
          </div>

          {/* System Architecture Overview */}
          <Card className="animate-slide-up border-2 hover:shadow-xl transition-all">
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-2xl">
                <Network className="h-6 w-6 text-primary" />
                System Architecture Overview
              </CardTitle>
              <CardDescription className="text-base">
                High-level overview of how all components work together in the application
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="grid gap-6 md:grid-cols-2">
                <div className="space-y-3">
                  <h4 className="font-semibold text-green-600 dark:text-green-400 mb-3 flex items-center gap-2">
                    <GitBranch className="h-5 w-5" />
                    Data Flow Pipeline
                  </h4>
                  <ul className="space-y-2 text-sm">
                    {[
                      "Peer connection establishment via WebRTC handshake",
                      "File selection and chunking preparation (64KB chunks)",
                      "Encrypted chunk transfer via DataChannel with DTLS",
                      "Real-time progress and status updates to UI",
                      "File reassembly and SHA-256 integrity verification",
                      "Storage in IndexedDB with metadata and history",
                    ].map((item, idx) => (
                      <li key={idx} className="flex items-start gap-2">
                        <ChevronRight className="h-4 w-4 mt-0.5 text-green-500 flex-shrink-0" />
                        <span className="leading-relaxed">{item}</span>
                      </li>
                    ))}
                  </ul>
                </div>
                <div className="space-y-3">
                  <h4 className="font-semibold text-blue-600 dark:text-blue-400 mb-3 flex items-center gap-2">
                    <Layers className="h-5 w-5" />
                    Component Integration
                  </h4>
                  <ul className="space-y-2 text-sm">
                    {[
                      "Event-driven architecture for real-time updates",
                      "Shared React Context for cross-component state",
                      "Automatic storage and analytics synchronization",
                      "Unified performance monitoring across all features",
                      "Centralized error handling and user notifications",
                      "WebRTC stats aggregation for connection insights",
                    ].map((item, idx) => (
                      <li key={idx} className="flex items-start gap-2">
                        <ChevronRight className="h-4 w-4 mt-0.5 text-blue-500 flex-shrink-0" />
                        <span className="leading-relaxed">{item}</span>
                      </li>
                    ))}
                  </ul>
                </div>
              </div>

              {/* Architecture Diagram Description */}
              <div className="mt-6 p-4 bg-gradient-to-r from-primary/5 via-accent/5 to-primary/5 rounded-lg border border-primary/20">
                <h4 className="font-semibold text-primary mb-2 flex items-center gap-2">
                  <PackageCheck className="h-4 w-4" />
                  Architecture Layers
                </h4>
                <div className="grid gap-3 md:grid-cols-3 text-xs">
                  <div className="p-3 bg-background/50 rounded border border-border">
                    <div className="font-semibold mb-1 text-green-600 dark:text-green-400">Presentation Layer</div>
                    <div className="text-muted-foreground">React components, UI/UX, user interactions</div>
                  </div>
                  <div className="p-3 bg-background/50 rounded border border-border">
                    <div className="font-semibold mb-1 text-blue-600 dark:text-blue-400">Business Logic Layer</div>
                    <div className="text-muted-foreground">Hooks, state management, WebRTC handling</div>
                  </div>
                  <div className="p-3 bg-background/50 rounded border border-border">
                    <div className="font-semibold mb-1 text-purple-600 dark:text-purple-400">Data Layer</div>
                    <div className="text-muted-foreground">IndexedDB, localStorage, file storage</div>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Technical Insights */}
          <div className="grid gap-6 md:grid-cols-2">
            {/* Performance Insights */}
            <Card className="border-2 hover:shadow-lg transition-all">
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Gauge className="h-5 w-5 text-green-600 dark:text-green-400" />
                  Performance Benchmarks
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="flex items-center justify-between p-3 bg-green-50 dark:bg-green-950/20 rounded-lg">
                  <span className="text-sm font-medium">Typical Transfer Speed</span>
                  <Badge variant="secondary" className="bg-green-600 text-white">
                    10-20 MB/s
                  </Badge>
                </div>
                <div className="flex items-center justify-between p-3 bg-blue-50 dark:bg-blue-950/20 rounded-lg">
                  <span className="text-sm font-medium">Connection Latency</span>
                  <Badge variant="secondary" className="bg-blue-600 text-white">
                    {"<100ms"}
                  </Badge>
                </div>
                <div className="flex items-center justify-between p-3 bg-purple-50 dark:bg-purple-950/20 rounded-lg">
                  <span className="text-sm font-medium">Max File Size</span>
                  <Badge variant="secondary" className="bg-purple-600 text-white">
                    Unlimited
                  </Badge>
                </div>
                <div className="flex items-center justify-between p-3 bg-orange-50 dark:bg-orange-950/20 rounded-lg">
                  <span className="text-sm font-medium">Concurrent Peers</span>
                  <Badge variant="secondary" className="bg-orange-600 text-white">
                    Up to 10
                  </Badge>
                </div>
              </CardContent>
            </Card>

            {/* Security Highlights */}
            <Card className="border-2 hover:shadow-lg transition-all">
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <ShieldCheck className="h-5 w-5 text-blue-600 dark:text-blue-400" />
                  Security Features
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="flex items-start gap-3 p-3 bg-blue-50 dark:bg-blue-950/20 rounded-lg">
                  <Lock className="h-5 w-5 text-blue-600 dark:text-blue-400 flex-shrink-0" />
                  <div>
                    <div className="font-medium text-sm mb-1">End-to-End Encryption</div>
                    <div className="text-xs text-muted-foreground">AES-256 with DTLS 1.2 protocol</div>
                  </div>
                </div>
                <div className="flex items-start gap-3 p-3 bg-green-50 dark:bg-green-950/20 rounded-lg">
                  <KeyRound className="h-5 w-5 text-green-600 dark:text-green-400 flex-shrink-0" />
                  <div>
                    <div className="font-medium text-sm mb-1">Perfect Forward Secrecy</div>
                    <div className="text-xs text-muted-foreground">Ephemeral keys with automatic rotation</div>
                  </div>
                </div>
                <div className="flex items-start gap-3 p-3 bg-purple-50 dark:bg-purple-950/20 rounded-lg">
                  <Fingerprint className="h-5 w-5 text-purple-600 dark:text-purple-400 flex-shrink-0" />
                  <div>
                    <div className="font-medium text-sm mb-1">Zero-Knowledge Architecture</div>
                    <div className="text-xs text-muted-foreground">Server never sees your data</div>
                  </div>
                </div>
                <div className="flex items-start gap-3 p-3 bg-orange-50 dark:bg-orange-950/20 rounded-lg">
                  <CheckCircle className="h-5 w-5 text-orange-600 dark:text-orange-400 flex-shrink-0" />
                  <div>
                    <div className="font-medium text-sm mb-1">Integrity Verification</div>
                    <div className="text-xs text-muted-foreground">SHA-256 checksums for all transfers</div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>

          {/* AI Enhancement Notice */}
          <Alert className="animate-slide-up bg-gradient-to-r from-purple-50/90 via-pink-50/90 to-purple-50/90 dark:from-purple-950/30 dark:via-pink-950/30 dark:to-purple-950/30 border-2 border-purple-300 dark:border-purple-700">
            <Brain className="h-5 w-5 text-purple-600 dark:text-purple-400" />
            <AlertDescription className="ml-2">
              <strong className="text-purple-900 dark:text-purple-100">AI-Enhanced Analytics:</strong>
              <span className="text-purple-800 dark:text-purple-200">
                {" "}
                This application uses client-side AI algorithms for storage optimization, performance insights, and
                predictive analysis. All AI processing happens locally in your browser for maximum privacy and security.
                No data is sent to external AI services.
              </span>
            </AlertDescription>
          </Alert>
        </div>
      </main>

      <AppFooter />
    </div>
  )
}
